

#include "countingSmarties.h"


void prompt_and_exit(int status) {
   printf("Press any key to continue and close terminal\n");
   getchar();
   exit(status);
}

void print_message_to_file(FILE *fp, char message[]) {
 
   fprintf(fp,"The message is: %s\n", message);
}
int get_contours(Mat threshImage){
   RNG rng(12345);
   vector<vector<Point> > contours;
   vector<Vec4i> hierarchy;
   findContours( threshImage.clone(), contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0) );
   Mat drawing = Mat::zeros( threshImage.size(), CV_8UC3 );
   int counter = 0;
   int max_contour_area = get_max_contour_size(contours);

   for( size_t i = 0; i< contours.size(); i++ )
     { 
	   if(contourArea( contours[i],false)>0.4*max_contour_area){counter++;
       Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
       drawContours( drawing, contours, (int)i, color, 2, 8, hierarchy, 0, Point() );
	   }
   }
   
   imshow("Contours", drawing );
   return counter;

}

int  get_smarties_count_and_display(char *filename,void*){

   string inputWindowName       = "Input Image";
   string erodeWindowName       = "Eroded Image";
   //string contoursWindowName	= "Contours";
   int element_size = 6;
   
   Mat image,grayImage,threshImage,element,openImage,dtImage;
   namedWindow(inputWindowName, CV_WINDOW_AUTOSIZE); 
   //namedWindow(contoursWindowName, CV_WINDOW_AUTOSIZE);
   //namedWindow(erodeWindowName, CV_WINDOW_AUTOSIZE);
    
   image = imread(filename, CV_LOAD_IMAGE_COLOR);   // Read the file

   if (!image.data) {                               // Check for invalid input
      printf("Error: failed to read image\n");
      prompt_and_exit(-1);
   }
   CannyThreshold(image);
   cvtColor(image,grayImage,CV_BGR2GRAY);
   threshold(grayImage,threshImage,230,255,1);
   element = getStructuringElement( MORPH_RECT,
                                       Size( 2*element_size + 1, 2*element_size+1 ),
                                       Point(element_size, element_size));

   morphologyEx(threshImage.clone(), openImage,MORPH_OPEN, element);
   dilate(openImage,openImage,element);
   distanceTransform(openImage,dtImage, CV_DIST_L2, 5);
   normalize(dtImage,dtImage,255,1);
   //imshow("dt image",dtImage );  
   double dtImageMax,dtImageMin;
   minMaxLoc(dtImage*255,&dtImageMin,&dtImageMax);
   threshold(dtImage*255,dtImage,dtImageMax*0.68,255,CV_THRESH_BINARY);
   //imshow("dt thresh image",dtImage );
   morphologyEx(dtImage,dtImage,MORPH_OPEN, element);

  // cout << "dtImage = "<< endl << " " << dtImage << endl << endl;
   imshow(inputWindowName,image );  
   //imshow(erodeWindowName,openImage); // show our image inside it.
   //imshow("Distance transform",dtImage);
   
   do{
      waitKey(30);                                  // Must call this to allow openCV to display the images
   } while (!_kbhit());                             // We call it repeatedly to allow the user to move the windows
                                                    // (if we don't the window process hangs when you try to click and drag)
   
   getchar(); // flush the buffer from the keyboard hit

   //destroyWindow(inputWindowName);  
   //destroyWindow(erodeWindowName);
   Mat image_f;
   dtImage.convertTo(image_f, CV_8UC1);
   return get_contours(image_f);//contours.size();
}
void CannyThreshold(Mat img)
{  
   Mat src_gray;
   Mat src_blur;
   Mat detected_edges,threshImage,output,im_out;
   int cannyThreshold =50; 
   int gaussian_std_dev = 1; 

   double sigma = 2.0;
   int ratio = 3;
   int kernel_size = 3;
   int filter_size;
   int element_size = 1;
   filter_size = gaussian_std_dev * 4 + 1;  // multiplier must be even to ensure an odd filter size as required by OpenCV
                                            // this places an upper limit on gaussian_std_dev of 7 to ensure the filter size < 31
                                            // which is the maximum size for the Laplacian operator
   cvtColor(img, src_gray, CV_BGR2GRAY);
   threshold(src_gray,threshImage,230,255,1);
   //GaussianBlur(src_gray, src_blur, Size(31,31), sigma);
   GaussianBlur(src_gray, src_blur, Size(filter_size,filter_size), gaussian_std_dev);
   Canny( src_blur, detected_edges, cannyThreshold, cannyThreshold*ratio, kernel_size );
   Mat element = getStructuringElement( MORPH_RECT,
                                       Size( 2*element_size + 1, 2*element_size+1 ),
                                       Point(element_size, element_size));
   Mat close_element = getStructuringElement( MORPH_RECT,
                                       Size( 2*element_size + 3, 2*element_size+3 ),
                                       Point(element_size, element_size));
   //dilate(detected_edges,detected_edges,element);
   imshow( "canny", detected_edges );
   subtract(threshImage,detected_edges,output);
   erode(output,output,element);
   morphologyEx(output,output,MORPH_CLOSE,element);
   im_out = output.clone();
   imshow("diff",output);
   flood_fill(im_out);
   imshow("interm flood",im_out);
   flood_fill(im_out);
   //morphologyEx(output,output,MORPH_CLOSE,close_element);
   imshow("flood",im_out);
 
   cout<<get_contours(im_out)<<endl;
 }
void flood_fill(Mat img){

   Mat im_floodfill = img.clone();
  
   floodFill(im_floodfill, cv::Point(0,0), Scalar(255));
     
    // Invert floodfilled image
   Mat im_floodfill_inv;
   bitwise_not(im_floodfill, im_floodfill_inv);
     
    // Combine the two images to get the foreground.
   img = (img | im_floodfill_inv);


}
int get_max_contour_size(vector<vector<Point> > contours){
  int largest_area=0;
  for( int i = 0; i< contours.size(); i++ ) // iterate through each contour. 
      {
       double a=contourArea( contours[i],false);  //  Find the area of contour
	  
       if(a>largest_area){
       largest_area=a;

       }
  
      }
return largest_area;
}